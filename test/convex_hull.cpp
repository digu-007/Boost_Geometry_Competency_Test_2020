/*
    Boost Competency Test - GSoC 2020
    digu_J - Digvijay Janartha
    NIT Hamirpur - INDIA
*/

#include <algorithm>
#include <iostream>
#include <iterator>
#include <utility>
#include <vector>
#include <random>
#include <chrono>

#include <boost/geometry/geometry.hpp>

#include "../includes/convex_hull_gift_wrapping.hpp"

namespace bg = boost::geometry;
using bg::dsv;

typedef bg::model::point<double, 2, bg::cs::cartesian> point_t;
typedef bg::model::multi_point<point_t> mpoint_t;
typedef bg::model::polygon<point_t> polygon_t;

std::mt19937_64 rang(std::chrono::high_resolution_clock::now().time_since_epoch().count());

int my_rand(int l, int r)
{
    if (l > r)
    {
        std::swap(l, r);
    }
	std::uniform_int_distribution <int> uid(l, r);
	return uid(rang);
}

bool test(mpoint_t &hull1, mpoint_t &hull2)
{   
    // Checks if the convex hull generated by gift wrapping is the same as the convex hull generated by boost geometry.
    polygon_t p1, p2;
    for (int i = 0; i < boost::size(hull1); ++i)
    {
        bg::append(p1, hull1[i]);
    }
    for (int i = int(boost::size(hull2)) - 1; i >= 0; --i)
    {
        bg::append(p2, hull2[i]);
    }
    if (bg::covered_by(p1, p2) and bg::covered_by(p2, p1)) // both geometries must cover themselves to be same
    {
        return true;
    }
    std::cout << dsv(p1) << "\n";
    std::cout << dsv(p2) << "\n";
    return false;
}

int main()
{
    std::cout << std::fixed << std::setprecision(0);
    #ifdef HOME
        freopen("input.txt", "r", stdin);
        freopen("output.txt", "w", stdout);
    #endif

    for (int tt = 1; tt <= 500; ++tt) // 500 random test cases
    {
        mpoint_t mpt1, hull1, hull2;

        int points = 30;
        for (int i = 0; i < points; ++i)
        {
            int x = my_rand(0, 100);
            int y = my_rand(0, 100);
            bg::append(mpt1, point_t(x, y));
        }

        algo1::GiftWrapping(mpt1, hull1);
        bg::convex_hull(mpt1, hull2);
        assert(test(hull1, hull2) == true);
    }

    return 0;
}
